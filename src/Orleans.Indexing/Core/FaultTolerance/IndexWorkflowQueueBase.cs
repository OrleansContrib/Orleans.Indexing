using Orleans.Concurrency;
using Orleans.Runtime;
using Orleans.Storage;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Orleans.Indexing
{
    /// <summary>
    /// To minimize the number of RPCs, we process index updates for each grain on the silo where the grain is active. To do this processing, each silo
    /// has one or more <see cref="IndexWorkflowQueueGrainService"/>s for each grain class, up to the number of hardware threads. A GrainService is a grain that
    /// belongs to a specific silo.
    /// + Each of these GrainServices has a queue of workflowRecords, which describe updates that must be propagated to indexes. Each workflowRecord contains
    ///   the following information:
    ///    - workflowID: grainID + a sequence number
    ///    - memberUpdates: the updated values of indexed fields
    ///  
    ///   Ordinarily, these workflowRecords are for grains that are active on <see cref="IndexWorkflowQueueGrainService"/>'s silo. (This may not be true for
    ///   short periods when a grain migrates to another silo or after the silo recovers from failure).
    /// 
    /// + The <see cref="IndexWorkflowQueueGrainService"/> grain Q has a dictionary updatesOnWait is an in-memory dictionary that maps each grain G to the
    ///   workflowRecords for G that are waiting for be updated.
    /// </summary>
    internal class IndexWorkflowQueueBase : IIndexWorkflowQueue
    {
        //the persistent state of IndexWorkflowQueue, including:
        // - doubly linked list of workflowRecordds
        // - the identity of the IndexWorkflowQueue GrainService
        protected IndexWorkflowQueueState queueState;

        //the tail of workflowRecords doubly linked list
        internal IndexWorkflowRecordNode _workflowRecordsTail;

        //the grain storage for the index workflow queue
        private volatile IGrainStorage StorageProvider;

        private int _queueSeqNum;
        private Type _grainInterfaceType;
        private string _grainTypeName;

        private bool HasAnyTotalIndex => GetHasAnyTotalIndex();
        private bool? __hasAnyTotalIndex = null;

        private bool _isDefinedAsFaultTolerantGrain;
        private bool IsFaultTolerant => _isDefinedAsFaultTolerantGrain && HasAnyTotalIndex;

        private IIndexWorkflowQueueHandler __handler;
        private IIndexWorkflowQueueHandler Handler => InitWorkflowQueueHandler();

        private int _isHandlerWorkerIdle;

        /// <summary>
        /// This lock is used to queue all the writes to the storage and do them in a single batch, i.e., group commit
        /// 
        /// Works hand-in-hand with pendingWriteRequests and writeRequestIdGen.
        /// </summary>
        private AsyncLock _writeLock;

        /// <summary>
        /// Creates a unique ID for each write request to the storage.
        /// 
        /// The values generated by this ID generator are used in pendingWriteRequests
        /// </summary>
        private int _writeRequestIdGen;

        /// <summary>
        /// All the write requests that are waiting behind write_lock are accumulated
        /// in this data structure, and all of them will be done at once.
        /// </summary>
        private HashSet<int> _pendingWriteRequests;

        public const int BATCH_SIZE = int.MaxValue;

        private SiloAddress _silo;
        private SiloIndexManager SiloIndexManager;
        private Lazy<GrainReference> _lazyParent;
        private GrainReference _recoveryGrainReference;

        internal IndexWorkflowQueueBase(SiloIndexManager siloIndexManager, Type grainInterfaceType, int queueSequenceNumber, SiloAddress silo,
                                        bool isDefinedAsFaultTolerantGrain, Func<GrainReference> parentFunc, GrainReference recoveryGrainReference = null)
        {
            queueState = new IndexWorkflowQueueState();
            _grainInterfaceType = grainInterfaceType;
            _queueSeqNum = queueSequenceNumber;
            _grainTypeName = "Orleans.Indexing.IndexWorkflowQueue-" + IndexUtils.GetFullTypeName(_grainInterfaceType);

            _workflowRecordsTail = null;
            __handler = null;
            _isHandlerWorkerIdle = 1;

            _isDefinedAsFaultTolerantGrain = isDefinedAsFaultTolerantGrain;
            this._recoveryGrainReference = recoveryGrainReference;

            _writeLock = new AsyncLock();
            _writeRequestIdGen = 0;
            _pendingWriteRequests = new HashSet<int>();

            _silo = silo;
            SiloIndexManager = siloIndexManager;
            _lazyParent = new Lazy<GrainReference>(parentFunc, true);
        }

        private IIndexWorkflowQueueHandler InitWorkflowQueueHandler()
            => __handler = _lazyParent.Value.IsGrainService
                            ? SiloIndexManager.GetGrainService<IIndexWorkflowQueueHandler>(
                                    IndexWorkflowQueueHandlerBase.CreateIndexWorkflowQueueHandlerGrainReference(SiloIndexManager, _grainInterfaceType, _queueSeqNum, _silo))
                            : SiloIndexManager.GrainFactory.GetGrain<IIndexWorkflowQueueHandler>(CreateIndexWorkflowQueuePrimaryKey(_grainInterfaceType, _queueSeqNum));

        private async Task EnsureStorage()
        {
            if (this.StorageProvider == null)
            {
                using (await _writeLock.LockAsync())
                {
                    if (this.StorageProvider == null)   // Make sure another thread didn't get it
                    {
                        var readGrainReference = this._recoveryGrainReference ?? _lazyParent.Value;
                        this.StorageProvider = typeof(IndexWorkflowQueueGrainService).GetGrainStorage(this.SiloIndexManager.ServiceProvider);
                        await this.StorageProvider.ReadStateAsync(_grainTypeName, readGrainReference, this.queueState);
                    }
                }
            }
        }
        
        public async Task AddAllToQueue(Immutable<List<IndexWorkflowRecord>> workflowRecords)
        {
            await this.EnsureStorage();

            // Note: this can be called with an empty enumeration, to just "wake up" the thread in FT recovery.
            List<IndexWorkflowRecord> newWorkflows = workflowRecords.Value;
            foreach (IndexWorkflowRecord newWorkflow in newWorkflows)
            {
                AddToQueueNonPersistent(newWorkflow);
            }

            InitiateWorkerThread();
            await (IsFaultTolerant ? PersistState() : Task.CompletedTask);
        }

        public async Task AddToQueue(Immutable<IndexWorkflowRecord> workflow)
        {
            await this.EnsureStorage();

            AddToQueueNonPersistent(workflow.Value);

            InitiateWorkerThread();
            await (IsFaultTolerant ? PersistState() : Task.CompletedTask);
        }

        private void AddToQueueNonPersistent(IndexWorkflowRecord newWorkflow)
        {
            var newWorkflowNode = new IndexWorkflowRecordNode(newWorkflow);
            if (_workflowRecordsTail == null) //if the list is empty
            {
                _workflowRecordsTail = newWorkflowNode;
                queueState.State.WorkflowRecordsHead = newWorkflowNode;
            }
            else // otherwise append to the end of the list
            {
                _workflowRecordsTail.Append(newWorkflowNode, ref _workflowRecordsTail);
            }
        }

        public async Task RemoveAllFromQueue(Immutable<List<IndexWorkflowRecord>> workflowRecords)
        {
            await this.EnsureStorage();

            List<IndexWorkflowRecord> newWorkflows = workflowRecords.Value;
            foreach (IndexWorkflowRecord newWorkflow in newWorkflows)
            {
                RemoveFromQueueNonPersistent(newWorkflow);
            }
            await (IsFaultTolerant ? PersistState() : Task.CompletedTask);
        }

        private void RemoveFromQueueNonPersistent(IndexWorkflowRecord newWorkflow)
        {
            for (var current = queueState.State.WorkflowRecordsHead; current != null; current = current.Next)
            {
                if (newWorkflow.Equals(current.WorkflowRecord))
                {
                    current.Remove(ref queueState.State.WorkflowRecordsHead, ref _workflowRecordsTail);
                    return;
                }
            }
        }

        private void InitiateWorkerThread()
        {
            if (this.SiloIndexManager.InjectableCode.ShouldRunQueueThread(() => Interlocked.Exchange(ref _isHandlerWorkerIdle, 0) == 1))
            {
                IndexWorkflowRecordNode punctuatedHead = AddPunctuationAt(BATCH_SIZE);
                Handler.HandleWorkflowsUntilPunctuation(punctuatedHead.AsImmutable()).Ignore();
            }
        }

        private IndexWorkflowRecordNode AddPunctuationAt(int batchSize)
        {
            if (_workflowRecordsTail == null) throw new WorkflowIndexException("Adding a punctuation to an empty workflow queue is not possible.");

            var punctuationHead = queueState.State.WorkflowRecordsHead;
            if (punctuationHead.IsPunctuation) throw new WorkflowIndexException("The element at the head of workflow queue cannot be a punctuation.");

            if (batchSize == int.MaxValue)
            {
                var punctuation = _workflowRecordsTail.AppendPunctuation(ref _workflowRecordsTail);
                return punctuationHead;
            }
            var punctuationLoc = punctuationHead;

            for (int i = 1; i < batchSize && punctuationLoc.Next != null; ++i)
            {
                punctuationLoc = punctuationLoc.Next;
            }
            punctuationLoc.AppendPunctuation(ref _workflowRecordsTail);
            return punctuationHead;
        }

        private List<IndexWorkflowRecord> RemoveFromQueueUntilPunctuation(IndexWorkflowRecordNode from)
        {
            List<IndexWorkflowRecord> workflowRecords = new List<IndexWorkflowRecord>();
            if (from != null && !from.IsPunctuation)
            {
                workflowRecords.Add(from.WorkflowRecord);
            }

            IndexWorkflowRecordNode tmp = from?.Next;
            while (tmp != null && !tmp.IsPunctuation)
            {
                workflowRecords.Add(tmp.WorkflowRecord);
                tmp = tmp.Next;
                tmp.Prev.Clean();
            }

            if (tmp == null)
            {
                from.Remove(ref queueState.State.WorkflowRecordsHead, ref _workflowRecordsTail);
            }
            else
            {
                from.Next = tmp;
                tmp.Prev = from;
                from.Remove(ref queueState.State.WorkflowRecordsHead, ref _workflowRecordsTail);
                tmp.Remove(ref queueState.State.WorkflowRecordsHead, ref _workflowRecordsTail);
            }

            return workflowRecords;
        }

        private async Task PersistState()
        {
            //create a write-request ID, which is used for group commit
            int writeRequestId = ++_writeRequestIdGen;

            //add the write-request ID to the pending write requests
            _pendingWriteRequests.Add(writeRequestId);

            //wait before any previous write is done
            using (await _writeLock.LockAsync())
            {
                // If the write request is not there, it was handled by another worker before we obtained the lock.
                if (_pendingWriteRequests.Contains(writeRequestId))
                {
                    //clear all pending write requests, as this attempt will do them all.
                    _pendingWriteRequests.Clear();

                    //write the state back to the storage unconditionally
                    var saveETag = this.queueState.ETag;
                    try
                    {
                        this.queueState.ETag = StorageProviderUtils.ANY_ETAG;
                        await StorageProvider.WriteStateAsync(_grainTypeName, _lazyParent.Value, this.queueState);
                    }
                    finally
                    {
                        if (this.queueState.ETag == StorageProviderUtils.ANY_ETAG)
                        {
                            this.queueState.ETag = saveETag;
                        }
                    }
                }
            }
        }

        private static Immutable<IndexWorkflowRecordNode> EmptyIndexWorkflowRecordNode = new Immutable<IndexWorkflowRecordNode>(null);

        public Task<Immutable<IndexWorkflowRecordNode>> GiveMoreWorkflowsOrSetAsIdle()
        {
            List<IndexWorkflowRecord> removedWorkflows = RemoveFromQueueUntilPunctuation(queueState.State.WorkflowRecordsHead);
            if (IsFaultTolerant)
            {
                //The task of removing the workflow record IDs from the grain runs in parallel with persisting the state. At this point, there
                //is a possibility that some workflow record IDs do not get removed from the indexable grains while the workflow record is removed
                //from the queue. This is fine, because having some dangling workflow IDs in some indexable grains is harmless.
                //TODO: add a garbage collector that runs once in a while and removes the dangling workflow IDs (i.e., the workflow IDs that exist in the
                //      indexable grain, but its corresponding workflow record does not exist in the workflow queue.
                //Task.WhenAll(
                //    RemoveWorkflowRecordsFromIndexableGrains(removedWorkflows),
                this.PersistState(//)
            ).Ignore();
            }

            if (_workflowRecordsTail == null)
            {
                _isHandlerWorkerIdle = 1;
                return Task.FromResult(EmptyIndexWorkflowRecordNode);
            }
            else
            {
                _isHandlerWorkerIdle = 0;
                return Task.FromResult(AddPunctuationAt(BATCH_SIZE).AsImmutable());
            }
        }

        private bool GetHasAnyTotalIndex()
        {
            if (!__hasAnyTotalIndex.HasValue)
            {
                __hasAnyTotalIndex = SiloIndexManager.IndexFactory.GetGrainIndexes(_grainInterfaceType).HasAnyTotalIndex;
            }
            return __hasAnyTotalIndex.Value;
        }

        public async Task<Immutable<List<IndexWorkflowRecord>>> GetRemainingWorkflowsIn(HashSet<Guid> activeWorkflowsSet)
        {
            await this.EnsureStorage();

            var result = new List<IndexWorkflowRecord>();
            for (var current = queueState.State.WorkflowRecordsHead; current != null && !current.IsPunctuation; current = current.Next)
            {
                if (activeWorkflowsSet.Contains(current.WorkflowRecord.WorkflowId))
                {
                    result.Add(current.WorkflowRecord);
                }
            }
            return result.AsImmutable();
        }

        public Task Initialize(IIndexWorkflowQueue oldParentGrainService)
            => throw new NotSupportedException();

#region STATIC HELPER FUNCTIONS
        public static GrainReference CreateIndexWorkflowQueueGrainReference(SiloIndexManager siloIndexManager, Type grainInterfaceType, int queueSeqNum, SiloAddress siloAddress)
            => CreateGrainServiceGrainReference(siloIndexManager, grainInterfaceType, queueSeqNum, siloAddress);

        public static string CreateIndexWorkflowQueuePrimaryKey(Type grainInterfaceType, int queueSeqNum)
            => $"{IndexUtils.GetFullTypeName(grainInterfaceType)}-{queueSeqNum}";

        private static GrainReference CreateGrainServiceGrainReference(SiloIndexManager siloIndexManager, Type grainInterfaceType, int queueSeqNum, SiloAddress siloAddress)
            => siloIndexManager.MakeGrainServiceGrainReference(IndexingConstants.INDEX_WORKFLOW_QUEUE_GRAIN_SERVICE_TYPE_CODE,
                                                               CreateIndexWorkflowQueuePrimaryKey(grainInterfaceType, queueSeqNum), siloAddress);

        public static IIndexWorkflowQueue GetIndexWorkflowQueueFromGrainHashCode(SiloIndexManager siloIndexManager, Type grainInterfaceType, int grainHashCode, SiloAddress siloAddress)
        {
            int queueSeqNum = StorageProviderUtils.PositiveHash(grainHashCode, siloIndexManager.NumWorkflowQueuesPerInterface);
            var grainReference = CreateGrainServiceGrainReference(siloIndexManager, grainInterfaceType, queueSeqNum, siloAddress);
            return siloIndexManager.GetGrainService<IIndexWorkflowQueue>(grainReference);
        }
#endregion STATIC HELPER FUNCTIONS
    }
}
